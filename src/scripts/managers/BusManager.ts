/**
 * Manages MiddlewareChain and Event Buses
 *
 * @module
 */

import { BusManagerContext_Init, BusManagerEmitter, BusManagerEvents } from '../types/Managers.js';
import { PluginEventMap, PluginInstance, PluginMiddlewareMap, PluginSettingsBase } from '../types/Plugin.js';
import { EnhancedEventEmitter } from '../utils/EnhancedEventEmitter.js';
import { MiddlewareChain, MiddlewareLink } from '../utils/Middleware.js';

/**
 * Type Guard for determining if an object is truly a `SilentlyFailChainError`
 *
 * @param err - An Error of unknown type.
 */
function isSilentlyFailChainError(err: unknown): err is SilentlyFailChainError {
  if (!err || false === err instanceof Error) {
    return false;
  }

  if (err && err.cause) {
    return Object.hasOwn((err as SilentlyFailChainError).cause, 'silentlyFailChain');
  }

  return false;
}

/**
 * An `Error` type for enforcing a silent failure of an entire chain.
 *
 * `throw` this error, or return an instance of it to a {@link Next | `Next`} function to
 * programattically bypass the current and remaining {@link MiddlewareLink | `MiddlewareLink`} in a {@link MiddlewareChain | `MiddlewareChain`}.
 *
 * If you're reading this documentation and are using vanilla JS, or don't need/want to import
 * this lib, you can implement the error like so:
 *
 * ```js
 * // Instantiate the error with a `cause.silentlyFailChain = true` to pass the runtime type test.
 * const err = new Error(
 *    'Some valid reason we want to just bail the Chain',
 *    {
 *      cause: {
 *          silentlyFailChain: true
 *      }
 *    }
 * );
 *
 * // Can call `next` with the `Error` instance (`err`)
 * next(err);
 *
 * // or, throw the `Error`
 * throw err;
 * ```
 */
export class SilentlyFailChainError extends Error {
  /**
   * Cause is predefined for instances
   */
  cause = {
    /**
     * The existence of this key on the `cause` object is how we test if the error type
     * is truly a `SilentlyFailChainError`
     */
    silentlyFailChain: true
  };

  /**
   * Create a new {@link SilentlyFailChainError | `SilentlyFailChainError`}.
   *
   * @param message - Justification for why the {@link MiddlewareChain | `MiddlewareChain`} is silently failing.
   */
  constructor(message: string) {
    super(message);
    (Error as any).captureStackTrace(this, SilentlyFailChainError);
  }
}

/**
 * Manages {@link MiddlewareChain | `MiddlewareChain`} and Event Buses.
 *
 * Protects {@link MiddlewareChain | `MiddlewareChain`} Execution by limiting it to the {@link PluginInstance | `PluginInstance`} that *first* Registered with the System.
 * > If you're writing a Plugin and need to be higher in the Chain, set your {@link PluginInstance.priority | Priority} to a lower value to load earlier (but be reasonable!).
 *
 * This class is also part of the {@link types/Plugin.PluginRegistrar | `PluginRegistrar`},
 * providing various Registration points.
 *
 * @typeParam PluginSettings - Shape of the Settings object the Plugin can access.
 */
export class BusManager<PluginSettings extends PluginSettingsBase> {
  /** Mapping of a Symbol generated by the first {@link PluginInstance | `PluginInstance`} to a {@link MiddlewareChain | `MiddlewareChain`}. */
  private chainPluginMap: Map<MiddlewareChain<{}>, Symbol> = new Map();
  /** Mapping of Chain Name to a {@link MiddlewareChain | `MiddlewareChain`}. */
  private chains: Map<string, MiddlewareChain<{}>> = new Map();
  /** `EventEmitter` instance for all Events in the System to broadcast on. */
  private _emitter: BusManagerEmitter;

  /**
   * Get a `Readonly` instance of the {@link BusManagerEmitter | `BusManagerEmitter`}.
   */
  get emitter(): Readonly<BusManagerEmitter> {
    return this._emitter;
  }

  /**
   * Create a new {@link BusManager | `BusManager`}.
   *
   * Also instantiates an `EventEmitter`.
   *
   * @typeParam PluginSettings - Shape of the Settings object the Plugin can access.
   */
  constructor() {
    this._emitter = new EnhancedEventEmitter();
  }

  /**
   * Initialize `BusManager` for executing {@link MiddlewareChain | `MiddlewareChain`}s.
   */
  init() {
    // Register "Middleware Execute" event to execute Chain
    this.emitter.on(BusManagerEvents.MIDDLEWARE_EXECUTE, this.startMiddlewareChainByName);
  }

  /**
   * Mark the `EventEmitter` as not allowing anymore `Listeners` to be added.
   *
   * > After calling this, attempting to call `on` or `addListener` on the `EventEmitter`
   * will throw an `Error`!
   */
  disableAddingListeners() {
    this._emitter.disableAddingListeners = true;
  }

  /**
   * Reset the `BusManager` by clearing all Chain, Mapping, and removing all Event `Listeners`.
   */
  reset = () => {
    this.chains = new Map();
    this.chainPluginMap = new Map();
    this._emitter.disableAddingListeners = false;
    this._emitter.removeAllListeners();
  };

  /**
   * Register Middleware with the system.
   *
   * @param plugin - Instance of the Plugin to register against.
   * @param queriedMiddleware - Middleware Chain Mapping to register with the Plugin instance.
   */
  registerMiddleware = (plugin: PluginInstance<PluginSettings>, queriedMiddleware: PluginMiddlewareMap | undefined) => {
    if (!queriedMiddleware) {
      return;
    }

    for (const [middlewareName, middlewareLinks] of Object.entries(queriedMiddleware)) {
      let chosenChain = this.chains.get(middlewareName);

      // This is the first registration for the Chain
      if (!chosenChain) {
        // Create a new Chain to be chosen
        chosenChain = new MiddlewareChain();
        // Register this plugin as the leader for this Chain
        this.chainPluginMap.set(chosenChain, plugin.ref);
        // Register this Chain for the middlewareName
        this.chains.set(middlewareName, chosenChain);

        console.info(`Registering '${plugin.name}' as leader of Chain: ${middlewareName}`);
      }

      chosenChain.use(...middlewareLinks);
    }

    // Register each MiddlewareChain with an Error MiddlewareLink
    for (const chain of this.chains.values()) {
      chain.use(this.errorMiddlewareLink);
    }
  };

  /**
   * Register Events with the system.
   *
   * @param plugin - Instance of the Plugin to register against.
   * @param eventMap - {@link PluginEventMap | `PluginEventMap`} for the currently Registering Plugin.
   */
  registerEvents = (plugin: PluginInstance<PluginSettings>, eventMap?: PluginEventMap) => {
    if (!eventMap) {
      return;
    }

    for (const [eventName, eventFunction] of Object.entries(eventMap)) {
      // AddListener on behalf of the plugin, and force-bind the function to the PluginInstance
      this.emitter.addListener(eventName, eventFunction.bind(plugin));
    }
  };

  /**
   * On an Event Trigger, we need to start a {@link MiddlewareChain | `MiddlewareChain`} by name,
   * as well as ensure the Plugin causing the Trigger is the very same that first Registered the
   * {@link MiddlewareChain | `MiddlewareChain`} attempting to be Executed.
   *
   * @param ctx - Initiating Context Object, housing the initial state of the Chain Context, as well as Plugin reference.
   */
  private startMiddlewareChainByName = async (ctx: BusManagerContext_Init<{}>) => {
    const links = this.chains.get(ctx.chainName);

    if (!links) {
      throw new Error('Middleware Chain does not exist: ' + ctx.chainName);
    }

    const leaderPlugin = this.chainPluginMap.get(links);

    if (false === (ctx.initiatingPlugin.ref === leaderPlugin)) {
      throw new Error(`This Plugin did not initiate this middleware (${ctx.chainName}): ${ctx.initiatingPlugin.name}`);
    }

    try {
      console.log(`Starting Chain: ${ctx.chainName}`);
      await links.execute(ctx.initialContext);
      console.log(`Ending Chain: ${ctx.chainName}`);
    } catch (err) {
      if (true === isSilentlyFailChainError(err)) {
        console.log(`Chain Catch - Force Fail Chain: ${ctx.chainName}`);
      } else {
        console.log(`Error in Chain: ${ctx.chainName}`);
        throw err;
      }
    }
  };

  /**
   * Error Handling {@link MiddlewareLink | `MiddlewareLink`}.
   *
   * This Handler is added to the end of every {@link MiddlewareChain | `MiddlewareChain`}
   * upon Registration, and as such is treated as an "Error Handler" for the entire Chain.
   * You can compare this to a `Promise.catch()`.
   *
   * @param _context - (Ignored) Contextual State passed from Link to Link.
   * @param next - `Next` function to call in order to progress Chain.
   * @param error - If supplied, the entire Chain is in Error.
   */
  private errorMiddlewareLink: MiddlewareLink<{}> = async (_context, next, error) => {
    if (error) {
      throw error;
    } else {
      await next();
    }
  };
}
