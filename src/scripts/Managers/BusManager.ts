/**
 * Manages MiddlewareChain and Event Buses
 *
 * @module
 */

import { BusContextProvider } from '../ContextProviders/BusContextProvider.js';
import { ApplicationIsLockedError } from '../ContextProviders/index.js';
import { BusManagerEmitter, CoreEvents } from '../types/Events.js';
import { BusManagerContext_Init, LockHolder } from '../types/Managers.js';
import { PluginEventRegistration, PluginInstance, PluginMiddlewareMap } from '../types/Plugin.js';
import { EnhancedEventEmitter } from '../utils/EnhancedEventEmitter.js';
import { MiddlewareChain, MiddlewareLink, SilentlyFailChainError } from '../utils/Middleware.js';

/**
 * Type Guard for determining if an object is truly a `SilentlyFailChainError`
 *
 * @param err - An Error of unknown type.
 */
function isSilentlyFailChainError(err: unknown): err is SilentlyFailChainError {
  if (!err || false === err instanceof Error) {
    return false;
  }

  if (err && err.cause) {
    return Object.hasOwn((err as SilentlyFailChainError).cause, 'silentlyFailChain');
  }

  return false;
}

type PluginBusMap = {
  events: PluginEventRegistration;
  middleware: PluginMiddlewareMap;
};

/**
 * Manages {@link MiddlewareChain | `MiddlewareChain`} and Event Buses.
 *
 * Protects {@link MiddlewareChain | `MiddlewareChain`} Execution by limiting it to the {@link types/Plugin.PluginInstance | `PluginInstance`} that *first* Registered with the Application.
 * > If you're writing a Plugin and need to be higher in the Chain, set your {@link PluginInstance.priority | `Priority`} to a lower value to load earlier (but be reasonable!).
 *
 * @typeParam PluginSettings - Shape of the Settings object the Plugin can access.
 */
export class BusManager {
  /** `EventEmitter` instance for all Events in the Application to broadcast on. */
  emitter: BusManagerEmitter = new EnhancedEventEmitter() as BusManagerEmitter;

  /** Our Context Provider for this Manager. */
  context?: BusContextProvider;

  /** Mapping of a Symbol generated by the first {@link PluginInstance | `PluginInstance`} to a {@link MiddlewareChain | `MiddlewareChain`} name. */
  private chainNamePluginRefMap: Map<string, Symbol> = new Map();

  /** Mapping of Chain Name to a {@link MiddlewareChain | `MiddlewareChain`}. */
  private chainNameChainMap: Map<string, MiddlewareChain> = new Map();

  /** Mapping of Plugin Ref to a `PluginBusMap`. */
  private pluginRefBusMap: Map<Symbol, PluginBusMap> = new Map();

  /**
   * Create a new {@link BusManager | `BusManager`}.
   *
   * @param lockHolder - Instance of {@link LockHolder | `LockHolder`} to evaluate Lock Status.
   */
  constructor(private lockHolder: LockHolder) {}

  /**
   * Initialize `BusManager` for executing {@link MiddlewareChain | `MiddlewareChain`}s.
   */
  async init() {
    this.context = new BusContextProvider(this);
    // Register "Middleware Execute" event to execute Chain
    this.emitter.on(CoreEvents.MiddlewareExecute, this.startMiddlewareChainByName);
  }

  /**
   * Reset the `BusManager` by clearing all Chain, Mapping, and removing all Event `Listeners`.
   */
  reset = () => {
    this.chainNameChainMap.clear();
    this.chainNamePluginRefMap.clear();
    this.pluginRefBusMap.clear();
    this.emitter.removeAllListeners();
  };

  /**
   * Register Middleware Links for Chains with the Application.
   *
   * @param plugin - Instance of the Plugin to act on.
   * @param registrationMap - Registration of the MiddlewareMap declarations for the Plugin.
   */
  registerMiddleware(plugin: PluginInstance, registrationMap: PluginMiddlewareMap): void {
    if (this.lockHolder.isLocked) {
      throw new ApplicationIsLockedError();
    }

    const refMap = this.pluginRefBusMap.get(plugin.ref) || ({} as PluginBusMap);
    refMap.middleware = registrationMap;
    this.pluginRefBusMap.set(plugin.ref, refMap);

    for (const [middlewareName, middlewareLinks] of Object.entries(registrationMap)) {
      let chosenChain = this.chainNameChainMap.get(middlewareName);

      // This is the first registration for the Chain
      if (!chosenChain) {
        // Create a new Chain to be chosen
        chosenChain = new MiddlewareChain();
        // Register this plugin as the leader for this Chain
        this.chainNamePluginRefMap.set(middlewareName, plugin.ref);
        // Register this Chain for the middlewareName
        this.chainNameChainMap.set(middlewareName, chosenChain);

        console.info(`Registering '${plugin.name}' as leader of Chain: ${middlewareName}`);
      }

      chosenChain.use(...middlewareLinks);
    }

    // Register each MiddlewareChain with an Error MiddlewareLink
    for (const chain of this.chainNameChainMap.values()) {
      chain.use(this.errorMiddlewareLink);
    }
  }

  /**
   * Register Sends/Recieves for Events with the Application.
   *
   * > Events are forcibly added from the given mapping, and will bind to the {@link PluginInstance | `PluginInstance`}.
   *
   * @param plugin - Instance of the Plugin to act on.
   * @param registrationMap - Registration of the Sends/Recieves declarations for the Plugin.
   */
  registerEvents(plugin: PluginInstance, registrationMap: PluginEventRegistration): void {
    const refMap = this.pluginRefBusMap.get(plugin.ref) || ({} as PluginBusMap);
    refMap.events = registrationMap;
    this.pluginRefBusMap.set(plugin.ref, refMap);

    if (registrationMap.recieves) {
      for (const [eventName, eventFunction] of Object.entries(registrationMap.recieves)) {
        // AddListener on behalf of the plugin, and force-bind the function to the PluginInstance
        this.emitter.addListener(eventName, eventFunction.bind(plugin));
      }
    }
  }

  /**
   * Unregister a Plugin from the Application.
   *
   * Removes known Registered Listeners, and the registered Links for Chains.
   *
   * @param plugin - Instance of the Plugin to act on.
   */
  unregister(plugin: PluginInstance): void {
    const pluginMap = this.pluginRefBusMap.get(plugin.ref);

    if (!pluginMap) {
      return;
    }

    // Unregister Events
    Object.entries(pluginMap.events.recieves || {}).forEach(([eventName, eventListener]) =>
      this.emitter.removeListener(eventName, eventListener)
    );

    // Unregister Middleware Links for all Chain Names in the mapping
    Object.entries(pluginMap.middleware || {}).forEach(([chainName, chainLinks]) => {
      const chain = this.chainNameChainMap.get(chainName);

      chainLinks.forEach(link => chain?.unuse(link));

      this.chainNameChainMap.delete(chainName);
    });

    // Unregister MiddlewareChain Name -> Plugin mappings
    for (const [name, pluginRef] of this.chainNamePluginRefMap.entries()) {
      if (pluginRef === plugin.ref) {
        this.chainNamePluginRefMap.delete(name);
      }
    }

    this.pluginRefBusMap.delete(plugin.ref);
  }

  /**
   * Error Handling {@link MiddlewareLink | `MiddlewareLink`}.
   *
   * This Handler is added to the end of every {@link MiddlewareChain | `MiddlewareChain`}
   * upon Registration, and as such is treated as an "Error Handler" for the entire Chain.
   * You can compare this to a `Promise.catch()`.
   *
   * @param _context - (Ignored) Contextual State passed from Link to Link.
   * @param next - `Next` function to call in order to progress Chain.
   * @param error - If supplied, the entire Chain is in Error.
   */
  private errorMiddlewareLink: MiddlewareLink = async (_context, next, error) => {
    if (error) {
      throw error;
    } else {
      await next();
    }
  };

  /**
   * On an Event Trigger, we need to start a {@link MiddlewareChain | `MiddlewareChain`} by name,
   * as well as ensure the Plugin causing the Trigger is the very same that first Registered the
   * {@link MiddlewareChain | `MiddlewareChain`} attempting to be Executed.
   *
   * @param ctx - Initiating Context Object, housing the initial state of the Chain Context, as well as Plugin reference.
   */
  private startMiddlewareChainByName = async (ctx: BusManagerContext_Init) => {
    const links = this.chainNameChainMap.get(ctx.chainName);

    if (!links) {
      throw new Error('Middleware Chain does not exist: ' + ctx.chainName);
    }

    const leaderPlugin = this.chainNamePluginRefMap.get(ctx.chainName);

    if (false === (ctx.initiatingPlugin.ref === leaderPlugin)) {
      throw new Error(`This Plugin did not initiate this middleware (${ctx.chainName}): ${ctx.initiatingPlugin.name}`);
    }

    try {
      console.log(`Starting Chain: ${ctx.chainName}`);
      await links.execute(ctx.initialContext);
      console.log(`Ending Chain: ${ctx.chainName}`);
    } catch (err) {
      if (true === isSilentlyFailChainError(err)) {
        console.log(`Chain Catch - Force Fail Chain: ${ctx.chainName}`);
      } else {
        console.log(`Error in Chain: ${ctx.chainName}`);
        throw err;
      }
    }
  };
}
